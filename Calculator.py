import numpy as np

# Encapsulated as a class but better to write as reglar functions instead 
# as python is not a purely OOP language and these don't hold data and thus don't
# require a class instance.
# Depends on the larger project and it's requirements of course.

class CustomStatistics:
    # Get's the job done, but algorithmically could probably be improved or simply use better 
    # libraries with optimized methods
    def p_corr(x:np.ndarray, y:np.ndarray) -> float:
        """calculate sample pearson correlation coefficient for two arrays"""
        x_mean = x - np.mean(x, axis=0)
        y_mean = y - np.mean(y, axis=0)
        x_mean_square = np.sqrt(np.sum(np.square(x_mean)))
        y_mean_square = np.sqrt(np.sum(np.square(y_mean)))
        xy = np.sum(x_mean * y_mean)

        return xy/(x_mean_square * y_mean_square)
    
    # private function to avoid repeating code
    def __list_extender(x:list) -> list:
        """
        Takes a list where each entry is a list of two elements and returns a single list where
        all intermediate positions are generated, adhering to the end-exclusiveness of the 2nd
        element in the inner list
        eg:
        input list: [[1,3],[3,5]]
        output list: [1,2,3,4]
        """
        positions: list = []
        for line in x:
            positions.extend([val for val in range(line[0], line[-1])])
        return positions

    # Easier to read/maintain and more "pythonic" but slower
    def count_overlaps(x:list, y:list) -> int:
        """Compare two lists and count the positions which overlap"""
        x_positions: list = CustomStatistics.__list_extender(x)
        y_positions: list = CustomStatistics.__list_extender(y)
        x_set: set = set(x_positions)
        return len(x_set.intersection(y_positions))
    
    # Harder to read/maintain but more efficient and takes about half the time 
    def count_overlaps_2(x:list, y:list) -> int:
        """Compare two lists and count the positions which overlap"""
        counter:int = 0

        i: int = 0 # Setting the starting location for inner loop
        for x_line in x:
            x_start, x_end = x_line
            x_set:set = set([val for val in range(x_start, x_end)])
            for index in range(i, len(y)):
                y_start, y_end = y[index]
                if x_start >= y_end: continue # Check for overlap, if not, skip iteration

                y_list:list  = [val for val in range(y_start, y_end)]
                counter += len(x_set.intersection(y_list))
                if x_end < y_end:
                    i = index # Avoid processing already resolved records.
                    break
        return counter

    def average(x:list, y:np.ndarray) -> float:
        """
        Computes the mean of a numpy array indexed on positional list generated by the list.
        Assumes that the list contains the start and stop positions and generates a 
        list of all positions to use as index.
        """
        x_positions: list = CustomStatistics.__list_extender(x)
        y_elements: np.ndarray = np.take(y, x_positions)
        return np.mean(y_elements)
        
